---
title:  "[C언어] 14. 동적 메모리 할당"
excerpt: "Dynamic Memory"
categories:
  - C_Programming
toc: true
toc_sticky: true
 
date: 2023-12-30
last_modified_at: 2023-12-30

published: true
---


## 동적 메모리

> Dynamic Mermory

동적메모리는 프로그램 실행중 할당받을 수 있는 메모리 공간입니다.

일반적인 정적 방식과 다르게, 배열의 길이를 코드로 제어할 수 있습니다.

<br />

### malloc

```c
int *p = (int *)malloc(sizeof(int));
```

동적 메모리를 선언하는 코드입니다.

포인터 변수를 선언하고, 원하는 메모리의 크기만큼 메모리를 할당하는 구조입니다.

![malloc](https://github.com/leehan416/Blog_comments/assets/35258105/0c77f4ae-e4ac-4f59-aa37-c1fd096f0255){: width="70%" height="70%"}{: .center}

함수의 매게변수로 할당할 메모리의 크기를 넣습니다.

<br />

> 형변환(casting)에 관하여

예시 코드에서는 `형변환`을 적용하였지만, 사실 필수적으로 작성할 필요는 없습니다.

의도에 맞추어 코드를 잘 작성하였다면, 컴퓨터가 알아서 형변환을 진행합니다.

<br />

하지만, 컴퓨터는 코드 작성자의 의도를 완전하게는 파악하지 못하고, 에러를 발생시킬 수 있습니다.

때문에, 안정적인 코드 작성을 위하여는 형변환이 권장되고 있습니다.

<br />

> sizeof() 함수

```c
int value = 10;

int size = sizeof(value);

```

매개변수로 들어오는 데이터 타입, 변수의 크기를 반환해주는 함수입니다.

byte 단위로 반환하기 때문에, 위 코드에서 `size`변수에는 `4`가 저장됩니다.

<br />

```c
int *p = (int *)malloc(sizeof(int));
```

`sizeof` 함수에 대하여 설명하였으니, 이제는 위 코드가 이해되실 겁니다.

`포인터 변수 p`에 `int`데이터 타입의 사이즈만큼 메모리를 할당하여 주는 것이죠.

<br />

### free()

```c
int *p = (int *)malloc(sizeof(int) * 10); 

free(p); // 메모리 해제    
```

할당되었던 메모리 공간을 헤제하는 함수입니다.

메모리를 헤제시키지 않으면, 낭비되는 데이터 공간이 많아져서 컴퓨터가 느려지게 됩니다.

이 현상을 `메모리 누수`라고 합니다. 

<br />

메모리 누수를 방지하기 위해서는 사용이 끝난 변수는 메모리를 헤제하여 메모리 누수를 방지할 수 있습니다.

만약 헤제된 변수로 접근할 경우엔 에러가 발생할 수 있기 때문에, 주의해야 합니다.

<br />

### 활용

```c
int *p = (int *)malloc(sizeof(int) * 10); 
```

포인터 글에서 설명했듯, 배열과 포인터는 거의 동일합니다. 

그렇기 때문에, 포인터를 배열과 같이 사용할 수 있다 설명했었죠.

배열을 포인터로 활용하는 방식이 동적 메모리를 할당하는 방식입니다.

<br />

```c
int arr[num] //error

int *arr = (int *)malloc(sizeof(int) * num); 
```

전에 설명했듯, 배열을 선언하는 과정에서 배열의 크기는 동적으로 변경할 수 없습니다.

배열을 선언할 때, 길이를 변수로 활용할 수 없다는 뜻이죠. 

하지만, 동적 메모리 할당방식으로는 활용할 수 있습니다.

<br />

```c
int *func(){
    int *p = (int *)malloc(sizeof(int));
    return p;
}
```

함수를 활용한 방식으로도 데이터를 할당할 수 있습니다.


<br />

<!-- 
## Linked List

배열을 다루다 보면, 데이터 전체를 이동하는 경우와 같이 자리 이동에서 큰 불편함이 있다. 

Linked List는 이러한 점을 간단하게 변경할 수 있고, 동적으로 생성할 수 있다.

```c
struct data{
    int i;
    int value;
    struct data *link; // 다음 노드 주소
};

// ㅁ->ㅁ->ㅁ->ㅁ->ㅁ-> ... ->NULL
```

스트럭쳐에 다음 노드 주소를 저장하기 때문에, 배열에 비해 데이터의 자유도가 높다. 

```c
for(struct data *p = list; p != NULL; p = p->link)
```

하지만, 원하는 데이터를 찾기 위해 배열에 비해 시간이 오래걸린다는 단점이 있다.

 -->

---
```
💡 지적 환영합니다
``` 